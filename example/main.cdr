
(def range-step (fn (a b step)
                  (if (< a b) (cons a (range-step (+ a step) b step)))))


(def (range a b)
    (if (< a b) (cons a (range-step (+ 1 a) b 1))))

;; reduce the function f over xs starting at i
(def (reduce f i xs)
     (if (nil? xs)
         i
         (reduce f (f i (first xs)) (rest xs))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn fib (n)
  (if (< n 2)
    n
    (+ (fib (- n 2)) (fib (- n 1)))))




(defn read-eval ()
  (do
    (print "CEDAR> ")
    (eval (macroexpand (read)))))

;; (let ((v nil))
;;   (def v (catch (read-eval)
;;            e (do (println "unhandled exception:" e) nil)))
;;   (if (not (= v :EOF))
;;     (do
;;       (println v)
;;       (recur nil))))




(class lazy-seq
  ;; the function that will be called eventually
  (def func nil)
  ;; if the lazy sequence has been evaluated yet
  (def evaluated nil)
  ;; the value stored in the list. will be filled
  ;; when .seq is called
  (def value :lazy-not-evaluated)
  ;; constructor. Takes the function that will be
  ;; evaluated on .seq
  (def (new self f) (set self 'func f))
  ;; implementations of first and rest
  (def (first self) (first (.seq self)))
  (def (rest self) (rest (.seq self)))
  ;; the seq function "steps" this lazy sequence.
  ;; this means it checks if it's been evaluated
  ;; yet, and if it needs to, evaluates the function
  ;; caching it's result and returning it. If it
  ;; has already been evaluated, there is no reason
  ;; in calling the function again and it returns
  ;; the value it had cached
  (def (seq self)
    (if self.evaluated self.value
      (do (set self 'evaluated t)
          (set self 'value (self.func)))))
  ;; convert the lazy list into a string.
  ;; WARNING: this will consume the *entire*
  ;; list
  (def (str self)
    (str "(" (join self " ") ")")))

(defmacro lazily (& expr)
  `(new lazy-seq (fn () (do ,@expr))))



(def (walk start)
  (lazily (cons start (walk (inc start)))))


;; TODO: add this to the stdlib
(def (contains? coll k)
  (cond (nil? coll) nil
        (= (first coll) k) true
        :otherwise (recur (rest coll) k)))

;; TODO: add to stdlib
(def (contains-where? coll pred)
  (cond (nil? coll) nil
        (pred (first coll)) true
        :otherwise (recur (rest coll) pred)))

;; TODO: add all flavours to stdlib
(def (contains-number? coll)
  (contains-where? coll number?))


(def (hexchar x)
  (get "0123456789ABCDEF" (bit-and x 0x0F)))

(def (hex x)
  (when (number? x)
    (cond (= 0 x) ""
          :else (str (hex (bit-shift-right x 4))
                     (hexchar (bit-and 0x0F x))))))




(class c-extension
  (def name "ext")
  (def c-files nil)
  (def (new self name c-files)
    (do
      (sets name name)
      (sets c-files c-files))))


(def (vrange n)
  (let [i 0
        v []]
    (if (< i n)
      (recur (inc i) (cons i v))
      v)))

(def (memoize f)
  (let [mem {}
        not-found-sym (gensym)]
    (fn (& args)
      (let [r (get mem args not-found-sym)]
        (if (= r not-found-sym)
          (set mem args (apply f args))
          r)))))



(def (lazy-filter pred coll)
  (if (nil? coll) nil
    (let [f (first coll)
          r (rest coll)]
      (if (pred f)
        (lazily (cons f (lazy-filter pred r)))
        (lazy-filter pred r)))))

;;  primes = sieve [2..]
;; sieve (p:ps) = p : sieve [x | x <- ps, mod x p /= 0]

(def (prime-filter p)
  (fn (x) (not= (mod x p) 0)))

(def (sieve _ps)
  (let [p  (first _ps)
        ps (rest _ps)]
    (lazily (cons p (sieve (lazy-filter (prime-filter p) ps))))))
(def (primes) (sieve (walk 2)))


(def (apply-to f)
  (fn (args)
    (apply f args)))

(def (transpose s)
  (apply vector (map (fn (x) (apply vector x))
                     (apply zip s))))
(def (nested-for f x y)
  (map (fn (a)
         (map (fn (b)
                (f a b)) y)) x))

(def (matmul-1 a b)
  (nested-for (fn (x y)
                (reduce + 0 (map (apply-to *) (zip x y)))) ;; f
              a ;; x
              (transpose b))) ;; y

(def (matmul a b)
  (apply vector (map (apply-to vector) (matmul-1 a b))))



(def A [[1 2 3]
        [4 5 6]
        [7 8 9]])

(def B [[1 0 0]
        [0 1 0]
        [0 0 1]])

