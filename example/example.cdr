
(def range-step (fn (a b step)
                  (if (< a b) (cons a (range-step (+ a step) b step)))))


(def (range a b)
    (if (< a b) (cons a (range-step (+ 1 a) b 1))))

;; reduce the function f over xs starting at i
(def (reduce f i xs)
     (if (nil? xs)
         i
         (reduce f (f i (first xs)) (rest xs))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn fib (n)
  (if (< n 2)
    n
    (+ (fib (- n 2)) (fib (- n 1)))))




(defn read-eval ()
  (do
    (print "CEDAR> ")
    (eval (macroexpand (read)))))

;; (let ((v nil))
;;   (def v (catch (read-eval)
;;            e (do (println "unhandled exception:" e) nil)))
;;   (if (not (= v :EOF))
;;     (do
;;       (println v)
;;       (recur nil))))






(class lazy-seq
  ;; the function that will be called eventually
  (def func nil)
  ;; if the lazy sequence has been evaluated yet
  (def evaluated nil)
  ;; the value stored in the list. will be filled
  ;; when .seq is called
  (def value :lazy-not-evaluated)
  ;; constructor. Takes the function that will be
  ;; evaluated on .seq
  (def (new self f) (set self 'func f))
  ;; implementations of first and rest
  (def (first self) (first (.seq self)))
  (def (rest self) (rest (.seq self)))
  ;; the seq function "steps" this lazy sequence.
  ;; this means it checks if it's been evaluated
  ;; yet, and if it needs to, evaluates the function
  ;; caching it's result and returning it. If it
  ;; has already been evaluated, there is no reason
  ;; in calling the function again and it returns
  ;; the value it had cached
  (def (seq self)
    (if self.evaluated self.value
      (do (set self 'evaluated t)
          (set self 'value (self.func)))))
  ;; convert the lazy list into a string.
  ;; WARNING: this will consume the *entire*
  ;; list
  (def (str self)
    (str "(" (join self " ") ")")))

(defmacro lazily (& expr)
  `(new lazy-seq (fn () (do ,@expr))))

(class lazy-range
  ;; constructor that loads in the values
  (def (new self lo hi st)
    (set-self lo lo)
    (set-self hi hi)
    (set-self st st))
  ;; convert the lazy list into a string.
  ;; WARNING: this will consume the *entire*
  ;; list
  (def (str self)
    (str "(" (join self " ") ")"))

  ;; overload first
  (def (first self) self.lo)
  ;; overload rest
  (def (rest self)
    (let [lo self.lo
          hi self.hi
          st self.st]
      (println "REST")
      (if (or (= hi :inf) (not (> hi lo)))
        (new lazy-range (+ lo st) hi st)
        :wqw))))




(defmacro struct (id & fields)
  (do
    (println fields)
    (let [fsets (map (fn (fname)
                       `(set-self ,fname ,fname))
                     fields)]
        `(class ,id
            (def (new self ,@fields)
              (do ,@fsets))))))


;; TODO: add this to the stdlib
(def (contains? coll k)
  (cond (nil? coll) nil
        (= (first coll) k) true
        :otherwise (recur (rest coll) k)))

;; TODO: add to stdlib
(def (contains-where? coll pred)
  (cond (nil? coll) nil
        (pred (first coll)) true
        :otherwise (recur (rest coll) pred)))

;; TODO: add all flavours to stdlib
(def (contains-number? coll)
  (contains-where? coll number?))


(def (hexchar x)
  (get "0123456789ABCDEF" (bit-and x 0x0F)))

(def (hex x)
  (when (number? x)
    (cond (= 0 x) ""
          :else (str (hex (bit-shift-right x 4))
                     (hexchar (bit-and 0x0F x))))))




(class c-extension
  (def name "ext")
  (def c-files nil)
  (def (new self name c-files)
    (do
      (set-self name name)
      (set-self c-files c-files))))


(class base
  (def (new self)
    (set-self foo 30)))

(class derived
  (:extends base)
  (def (new self)
    (println self)))

(def (vrange n)
  (let [i 0
        v []]
    (if (< i n)
      (recur (inc i) (cons i v))
      v)))

(def (memoize f)
  (let [mem {}
        not-found-sym (gensym)]
    (fn (& args)
      (let [r (get mem args not-found-sym)]
        (if (= r not-found-sym)
          (set mem args (apply f args))
          r)))))

(def memfib (memoize fib))
