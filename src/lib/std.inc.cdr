
; MIT License
;
; Copyright (c) 2018 Nick Wanninger
;
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
; copies of the Software, and to permit persons to whom the Software is
; furnished to do so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included in
; all copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
; SOFTWARE.


;; set the initial namespace to "core"
(def *ns* "core")

(def t 't)
(def true 'true)
(def false nil)

(def not (fn (x) (if x nil t)))
(def or (fn (x y) (if x x y)))
(def and (fn (x y) (if x y x)))


(def not= (fn not= (a b) (not (= a b))))


(def nil? (fn (v) (= v nil)))
(def list? (fn (v) (= (type-of v) :list)))
(def dict? (fn (v) (= (type-of v) :dict)))
(def vector? (fn (v) (= (type-of v) :vector)))
(def number? (fn (v) (= (type-of v) :number)))
(def string? (fn (v) (= (type-of v) :string)))
(def symbol? (fn (v) (= (type-of v) :symbol)))
(def keyword? (fn (v) (= (type-of v) :keyword)))



(def cdr/println println)

(def debug
  (fn (& args)
    (println "DEBUG:" (apply str args))))

(def map-1
  (fn (f l)
    (if (not (nil? l))
      (cons (f (first l))
            (map-1 f (rest l))))))


;;;;
;;;; MACRO EXPANDER
;;
;;  The Cedar macro expander is implemented in the language itself
;;  so unfortunately the macro expander cannot use macros in it's
;;  code. It's build around the (macroexpand) function and the
;;  semi-special cased defmacro form. macroexpand takes a quoted
;;  expression, and the defmacro function takes a quoted name,
;;  quoted list, and quoted body.
;;  The defmacro function will do analysis on the args and the body
;;  and store the raw args and the raw body in the macros dictionary
;;
;;;;

(def qq/expand (fn (x) x))


(def *macros* {})
;; defmacro takes the arguments, the args and the body and stores
;; it into the macros dict for later evaluation
(def defmacro
  (fn (id args body)
    (let* ((expander (eval (list 'fn (cedar/symbol (str "macro/" id)) args (qq/expand body)))))
      (set *macros* id expander)
      expander)))

;; list-specialize does special things to lists. like checks for . notation
;; on dictionaries, because you cannot create a macro for '.'
;; this will be replaced with a real implementation once cond is defined
(def macro/list-specialize
  (fn (l) l))


(def macroexpand-1
  (fn (expr)
    (do
      ;; only lists need to be macro expanded, cause they're calls.
      ;; so if it's not a list, just return the bare expression
      (if (not (list? expr))
        expr
        (do (def expr (macro/list-specialize expr))
          (if (= (first expr) 'quote)
            expr
            (let* ((form (first expr))
                   (args (map-1 macroexpand-1 (rest expr)))
                   (mac (get *macros* (first expr) nil)))
              (if (nil? mac)
                (cons form args)

                (do
                  ;; expand the macro by evaluating it with the arguments
                  (let* ((ex (apply mac args)))
                    (if (seq? ex)
                      (if (= (cedar/hash ex) (cedar/hash expr))
                        expr
                        (macroexpand-1 ex))
                      ex)))))))))))
;; macroexpand takes an expression as a value and returns the
;; value representation of the recursively expanded macro
(def macroexpand
  (fn (raw-expr)
    (macroexpand-1 raw-expr)))


(defmacro defn (name args & body)
  (list 'def name
        (list 'fn name args (cons 'do body))))

(defn inc (n) (+ n 1))
(defn dec (n) (- n 1))



(defmacro catch (id expr body)
  (list 'catch* (list 'fn nil expr) (list 'fn (list id) body)))


(defmacro when
  (c & body)
  (list 'if c (cons 'do body)))


(defmacro when-not
  (c & body)
  (list 'if c nil (cons 'do body)))


(def symbol cedar/symbol)

(let* ((gensym-id 0))
  (defn gensyms (s)
      (do (def gensym-id (inc gensym-id))
          (symbol (str s gensym-id))))
  (defn gensym () (gensyms "G__")))


(defmacro or (x y)
  (let* ((sym (gensyms "OR-")))
    (list 'let* (list (list sym x)) (list 'if sym sym y))))

(defmacro and (x y)
  (let* ((sym (gensyms "AND-")))
    (list 'let* (list (list sym x)) (list 'if sym y sym))))



(defn second (x) (first (rest x)))


(def next rest)


(defmacro cond (& a)
  (let* ((c (first a))
         (e (second a))
         (r (rest (rest a))))
    (list 'if c e
        (when r (cons 'cond r)))))



(defmacro % (a f b) (list f b a))

;; redefine the def special form to allow a more
;; complicated scheme-like function definition
;; ex: (def foo :bar) => defines foo to :bar
;;     (def (id x) x) => defines the id function
;; why have this *and* the defn macro? Why not.
(defmacro def (& args)
  (let* ((name (first args))
         (val  (second args)))
    (if (list? name)
      (list 'def (first name) (list 'fn (first name) (rest name) val))
      (list 'def name val))))


(def (not x)
  (if x nil true))

(def (atom? n)
  (cond (nil? n)     true
        (number? n)  true
        (string? n)  true
        (symbol? n)  true
        (keyword? n) true
        :else nil))




(defmacro dot (key obj & args)
  (cons (list 'get obj (list 'quote key)) (cons obj args)))




(def (internal/dot-expansion l)
  (let* ((key (second l))
         (obj (first (rest (rest l))))
         (args (rest (rest (rest l)))))
    (cons (list 'get obj key) (cons obj args))))


(def (macro/list-specialize l)
  (let* ((frst (first l)))
    (cond (= frst (symbol ".")) (cons 'dot (rest l))
          (= frst 'quasiquote) (qq/expand l)
          :else l)))


(def (every? pred coll)
  (cond (nil? coll) t
        (pred (first coll)) (recur pred (rest coll))
        :else nil))

(def (some? pred coll)
  (or (pred (first coll)) (recur pred (rest coll))))

(def (constantly x)
  (fn (& a) x))


(def (zip-lists ls)
  (let* ((c (map-1 first ls)))
    (cond (every? nil? c) nil
          :else (cons (map-1 first ls) (zip-lists (map-1 rest ls))))))


;; zip any number of lists together into a single list, the
;; nth of which contains the nth item in each list passed
(def (zip & lists)
  (zip-lists lists))

(def (map f & colls)
  (cond (nil? (rest colls)) (map-1 f (first colls))
        (map-1 f (zip-lists colls))))

(def (foldl f i xs)
  (if (nil? xs)
    i
    (recur f (f i (first xs)) (rest xs))))

(def (foldr f i xs)
  (if (nil? xs)
    i
    (f (first xs) (foldr f i (rest xs)))))


(def (reverse xs)
  (foldl (fn (a b) (cons b a)) () xs))


(def (filter pred coll)
  (foldr (fn (x r) (if (pred x) (cons x r) r))
         nil coll))

;;;;
(def (count* c xs)
  (if (nil? xs) c
    (recur (inc c) (rest xs))))


(def (count coll)
  (cond (vector? coll) (size coll)
        :else (count* 0 coll)))
;;;;


(defn inc (n) (+ n 1))
(defn dec (n) (- n 1))


(def (even? x)
  (if (number? x)
    (= 0 (bit-and x 0x01))
    (throw "even? needs a number")))

(def (odd? x)
  (not (even? x)))

(def reduce foldl)

(def car first)
(def cdr rest)
(def (caar x)   (car (car x)))
(def (cadr x)   (car (cdr x)))
(def (cdar x)   (cdr (car x)))
(def (cddr x)   (cdr (cdr x)))
(def (caaar x)  (car (car (car x))))
(def (caadr x)  (car (car (cdr x))))
(def (cadar x)  (car (cdr (car x))))
(def (caddr x)  (car (cdr (cdr x))))
(def (cdaar x)  (cdr (car (car x))))
(def (cdadr x)  (cdr (car (cdr x))))
(def (cddar x)  (cdr (cdr (car x))))
(def (cdddr x)  (cdr (cdr (cdr x))))
(def (caaaar x) (car (car (car (car x)))))
(def (caaadr x) (car (car (car (cdr x)))))
(def (caadar x) (car (car (cdr (car x)))))
(def (caaddr x) (car (car (cdr (cdr x)))))
(def (cadaar x) (car (cdr (car (car x)))))
(def (cadadr x) (car (cdr (car (cdr x)))))
(def (caddar x) (car (cdr (cdr (car x)))))
(def (cadddr x) (car (cdr (cdr (cdr x)))))
(def (cdaaar x) (cdr (car (car (car x)))))
(def (cdaadr x) (cdr (car (car (cdr x)))))
(def (cdadar x) (cdr (car (cdr (car x)))))
(def (cdaddr x) (cdr (car (cdr (cdr x)))))
(def (cddaar x) (cdr (cdr (car (car x)))))
(def (cddadr x) (cdr (cdr (car (cdr x)))))
(def (cdddar x) (cdr (cdr (cdr (car x)))))
(def (cddddr x) (cdr (cdr (cdr (cdr x)))))


(def (append-1 l1 l2)
  (if (nil? l1)
    l2
    (cons (first l1)
          (append-1 (rest l1) l2))))

(def (append & lists)
  (reduce append-1 (first lists) (rest lists)))


(def qq/transform-quasiquote-arg nil)
(def qq/transform nil)


(def (qq/transform form)
  (if (seq? form)
    (let* ((car (first form)))
        (cond (= car 'unquote)          (list 'list (cadr form))
              (= car 'unquote-splicing) (cadr form)
              :otherwise                (list 'list (qq/transform-quasiquote-arg form))))
    (list 'list (qq/transform-quasiquote-arg form))))


(def (qq/transform-compound compound)
  (if (atom? compound)
    (list (list 'quote compound))
    (cons (qq/transform (first compound)) (qq/transform-compound (rest compound)))))


(def (qq/transform-quasiquote-arg-list argument)
  (let* ((car (first argument)))
    (cond (= car 'unquote)          (cadr argument)
          (= car 'unquote-splicing) (throw "UNQUOTE-SPLICING UNIMPLEMENTED HERE")
          :else            (cons 'append (qq/transform-compound argument)))))


(def (qq/transform-quasiquote-arg argument)
  (cond (list? argument) (qq/transform-quasiquote-arg-list argument)
        :otherwise       (list 'quote argument)))


(def *qq-c* 0)

(def (qq/expand form)
    (cond (= form nil) nil
          (atom? form) form
          (= (first form) 'quasiquote) (qq/transform-quasiquote-arg (second form))
          :else (let* ((expanded (cons (qq/expand (first form)) (qq/expand (rest form)))))
                  (if (= (first expanded) 'quasiquote)
                    (qq/transform-quasiquote-arg (second expanded))
                    expanded))))

;;;;;;;;;;;;;;;;;;;;;;;;;; QUASIQUOTE IS VALID NOW ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def (drop n l)
  (cond (= n 0) l
        (nil? l) nil
        :else (drop (dec n) (rest l))))

(def (take n l)
  (cond (= n 0) nil
        (nil? l) nil
        :else (cons (first l) (take (dec n) (rest l)))))

(def (partition n coll)
  (do
    (let* ((p (take n coll)))
      (cond (nil? p) nil
            (= n (count p)) (cons p (partition n (drop n coll)))
            :else (list p)))))


(defmacro let (defs & body)
  (do
    (if (odd? (count defs))
       (throw "error in 'let' syntax. defs vector must be even lengthed")
       `(let* ,(partition 2 defs) ,@body))))




;; since setting dict entries with keys as idents is
;; so common, this macro automatically quotes the key
;; identifier so you dont have to think about it.
(defmacro setq (coll name val)
  `(set ,coll (quote ,name) ,val))

;; define a macro for use inside classes to clean up
;; the (set self 'name val) form. Cause it's ugly.
(defmacro sets (name val)
  `(set self (quote ,name) ,val))

(defmacro gets (name & r)
  `(get self (quote ,name) ,@r))





;; the object class is not defined yet, but it should resolve.
;; it should be nil until defined correctly
(def object nil)


(defmacro class (name & fields)
  `(let [object-defined (not (nil? object))]
      ,(if (not (symbol? name)) (throw (str "Invalid class name: " name)))
      ;; define the name as a global class
      (def ,name (cedar/make-class ',name))

      ;; map over each of the fields, expand them
      ;; and convert the defs as class fields
      (do ,@(map (fn (mexpr)
                   (let [expr (macroexpand mexpr)]
                     (cond (= 'def (first expr))
                           `(cedar/register-class-field ,name
                                                        ',(first (rest expr))
                                                        ,(first (rest (rest expr))))
                           (vector? expr) `(do ,@(map (fn (c) `(cedar/register-class-parent ,name ,c))
                                                      expr))
                           :else (throw (str "Invalid class field: " mexpr)))))
                 fields))

      ;; all classes inherit from `object` iff object is defined
      ;; but only as the last class it extends.
      (when object-defined
        (cedar/register-class-parent ,name object))))


(class object
  (def (str self)
    (str "<instance of " (gets __class__) ">"))
  (def (first self)
    (throw (str "'first' unimplemented on "
                (gets __class__))))
  (def (first self)
    (throw (str "'rest' unimplemented on "
                (gets __class__)))))



;; the stream class is a basic io class
;; it offers .write and .read
(class stream
  (def write nil)
  (def read nil))


(class file-descriptor [stream]
  (def fd nil)
  ;; constructor that
  (def (new self fd_arg)
    (sets fd fd_arg))
  (def (write self s)
    (os-write self.fd s))
  (def (read self n)
    (os-read self.fd n))
  (def (close self)
    (do (os-close self.fd)
        (sets fd nil))))

(def (fopen-flags path flags)
  (let [fd (os-open path flags)]
    (cond (= fd -1)  (throw (str "unable to open file '" path "'"))
          :otherwise (new file-descriptor fd))))

(def (fopen path)
  (fopen-flags path (bit-or O_RDWR O_APPEND O_CREAT)))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Base Exceptions

(class exception
  ;; the exception's message defaults to an empty string
  ;; to be filled in later
  (def what "")
  (def (new self m)
    (sets what m))
  (def (str self)
    (gets what)))


(class assertion-error [exception])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



(defmacro assert (stmt)
  `(if ,stmt true (throw (assertion-error (str "Assertion Failed: " `,stmt)))))


(def *out* (file-descriptor 0))
(def *err* (file-descriptor 1))
(def *in*  (file-descriptor 2))


(def (join l s)
  (reduce (fn (a b) (str a s b)) (str (first l)) (rest l)))

(def (write stream & things)
  (.write stream (apply str things)))

;; redefine print and println in terms of
;; *out* the stream class system
(def (print & things)
  (when-not (nil? things)
    (.write *out* (join things " "))))

(def (println & things)
  (+ (apply print things)
     (print "\n")))


(def (print-error & things)
  (do (.write *err* (join things " "))
      (.write *err* "\n")))



;; fifo queue data structure.
(class queue
  (def (new self)
    (sets buf []))

  (def (push self v)
    (sets buf (cons v self.buf)))

  (def (pop self)
    (let [v (first self.buf)]
      (sets buf (rest self.buf))
      (when (nil? self.buf)
        (sets buf []))
      v))

  (def (str self)
    (str "<queue " self.buf ">"))

  (def (empty? self)
    (= 0 (size self.buf)))
  ;; implement iteration methods
  (def (first self)
    (first self.buf))
  (def (rest self)
    (rest self.buf)))


;; filo stack data structure. Push onto the top, that item
;; is then the first to be popped off.
(class stack
  (def (new self)
    (sets buf nil))

  (def (push self v)
    (sets buf (cons v self.buf))
    self)

  (def (pop self)
    (let [v (first self.buf)]
      (sets buf (rest self.buf))
      v))

  (def (str self)
    (str "<stack " self.buf ">"))

  (def (first self)
    (first self.buf))

  (def (rest self)
    (rest self.buf)))


(class A
  (def (str self) "<A>"))
(class B
  (def (str self) "<B>"))
(class C [A B])


;; compose two functions into a single function
;; (f (g args...))
(def (comp f g)
  (fn (& xs) (f (apply g xs))))

;; takes a fn f and returns a function that
;; returns the logical not of f
(def (complement f)
  (fn (& args)
    (not (apply f args))))

;; takes a value x and returns a function that constantly
;; returns that value
(def (constantly x)
  (fn (& args) x))

